// Generated by CoffeeScript 1.3.3
(function() {
  var audioContext, buffer, bufferFillSize, bufferFiller, canvas, context, error, fft, fftSize, gauss, hp, i, lp, needle, sampleRate, success,
    __hasProp = {}.hasOwnProperty;

  window.AudioContext = window.AudioContext || window.mozAudioContext || window.webkitAudioContext || window.msAudioContext || window.oAudioContext;

  navigator.getUserMedia = navigator.getUserMedia || navigator.mozGetUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia;

  canvas = document.querySelector("canvas");

  needle = document.querySelector(".needle");

  context = canvas.getContext('2d');

  audioContext = new AudioContext();

  sampleRate = audioContext.sampleRate;

  fftSize = 8192;

  fft = new FFT(fftSize, sampleRate / 4);

  buffer = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; 0 <= fftSize ? _i < fftSize : _i > fftSize; i = 0 <= fftSize ? ++_i : --_i) {
      _results.push(0);
    }
    return _results;
  })();

  bufferFillSize = 2048;

  bufferFiller = audioContext.createJavaScriptNode(bufferFillSize, 1, 1);

  bufferFiller.onaudioprocess = function(e) {
    var b, input, _i, _j, _ref, _ref1, _results;
    input = e.inputBuffer.getChannelData(0);
    for (b = _i = bufferFillSize, _ref = buffer.length; bufferFillSize <= _ref ? _i < _ref : _i > _ref; b = bufferFillSize <= _ref ? ++_i : --_i) {
      buffer[b - bufferFillSize] = buffer[b];
    }
    _results = [];
    for (b = _j = 0, _ref1 = input.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; b = 0 <= _ref1 ? ++_j : --_j) {
      _results.push(buffer[buffer.length - bufferFillSize + b] = input[b]);
    }
    return _results;
  };

  gauss = new WindowFunction(DSP.GAUSS);

  lp = audioContext.createBiquadFilter();

  lp.type = lp.LOWPASS;

  lp.frequency = 8000;

  lp.Q = 0.1;

  hp = audioContext.createBiquadFilter();

  hp.type = hp.HIGHPASS;

  hp.frequency = 20;

  hp.Q = 0.1;

  success = function(stream) {
    var display, getPitch, maxPeakCount, maxPeaks, maxTime, noiseCount, noiseThreshold, process, render, src;
    maxTime = 0;
    noiseCount = 0;
    noiseThreshold = -Infinity;
    maxPeaks = 0;
    maxPeakCount = 0;
    src = audioContext.createMediaStreamSource(stream);
    src.connect(lp);
    lp.connect(hp);
    hp.connect(bufferFiller);
    bufferFiller.connect(audioContext.destination);
    process = function() {
      var b, bufferCopy, downsampled, firstFreq, freq, interp, left, noiseThrehold, p, peak, peaks, q, right, s, secondFreq, spectrumPoints, thirdFreq, upsampled, x, _i, _j, _k, _l, _len, _len1, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      bufferCopy = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = buffer.length; _i < _len; _i++) {
          b = buffer[_i];
          _results.push(b);
        }
        return _results;
      })();
      gauss.process(bufferCopy);
      downsampled = [];
      for (s = _i = 0, _ref = bufferCopy.length; _i < _ref; s = _i += 4) {
        downsampled.push(bufferCopy[s]);
      }
      upsampled = [];
      for (_j = 0, _len = downsampled.length; _j < _len; _j++) {
        s = downsampled[_j];
        upsampled.push(s);
        upsampled.push(0);
        upsampled.push(0);
        upsampled.push(0);
      }
      fft.forward(upsampled);
      if (noiseCount < 10) {
        _ref1 = fft.spectrum;
        for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
          i = _ref1[_k];
          noiseThreshold = Math.max(noiseThreshold, i);
        }
        noiseThrehold = noiseThreshold > 0.001 ? 0.001 : noiseThreshold;
        noiseCount++;
      }
      spectrumPoints = (function() {
        var _l, _ref2, _results;
        _results = [];
        for (x = _l = 0, _ref2 = fft.spectrum.length / 4; 0 <= _ref2 ? _l < _ref2 : _l > _ref2; x = 0 <= _ref2 ? ++_l : --_l) {
          _results.push({
            x: x,
            y: fft.spectrum[x]
          });
        }
        return _results;
      })();
      spectrumPoints.sort(function(a, b) {
        return b.y - a.y;
      });
      peaks = [];
      for (p = _l = 0; _l < 8; p = ++_l) {
        if (spectrumPoints[p].y > noiseThreshold * 5) {
          peaks.push(spectrumPoints[p]);
        }
      }
      if (peaks.length > 0) {
        for (p = _m = 0, _ref2 = peaks.length; 0 <= _ref2 ? _m < _ref2 : _m > _ref2; p = 0 <= _ref2 ? ++_m : --_m) {
          if (peaks[p] != null) {
            for (q = _n = 0, _ref3 = peaks.length; 0 <= _ref3 ? _n < _ref3 : _n > _ref3; q = 0 <= _ref3 ? ++_n : --_n) {
              if (p !== q && (peaks[q] != null)) {
                if (Math.abs(peaks[p].x - peaks[q].x) < 5) {
                  peaks[q] = null;
                }
              }
            }
          }
        }
        peaks = (function() {
          var _len2, _o, _results;
          _results = [];
          for (_o = 0, _len2 = peaks.length; _o < _len2; _o++) {
            p = peaks[_o];
            if (p != null) {
              _results.push(p);
            }
          }
          return _results;
        })();
        peaks.sort(function(a, b) {
          return a.x - b.x;
        });
        maxPeaks = maxPeaks < peaks.length ? peaks.length : maxPeaks;
        if (maxPeaks > 0) {
          maxPeakCount = 0;
        }
        peak = null;
        firstFreq = peaks[0].x * (sampleRate / fftSize);
        if (peaks.length > 1) {
          secondFreq = peaks[1].x * (sampleRate / fftSize);
          if ((1.4 < (_ref4 = firstFreq / secondFreq) && _ref4 < 1.6)) {
            peak = peaks[1];
          }
        }
        if (peaks.length > 2) {
          thirdFreq = peaks[2].x * (sampleRate / fftSize);
          if ((1.4 < (_ref5 = firstFreq / thirdFreq) && _ref5 < 1.6)) {
            peak = peaks[2];
          }
        }
        if (peaks.length > 1 || maxPeaks === 1) {
          if (!(peak != null)) {
            peak = peaks[0];
          }
          left = {
            x: peak.x - 1,
            y: Math.log(fft.spectrum[peak.x - 1])
          };
          peak = {
            x: peak.x,
            y: Math.log(fft.spectrum[peak.x])
          };
          right = {
            x: peak.x + 1,
            y: Math.log(fft.spectrum[peak.x + 1])
          };
          interp = 0.5 * ((left.y - right.y) / (left.y - (2 * peak.y) + right.y)) + peak.x;
          freq = interp * (sampleRate / fftSize);
          display.draw(freq);
        }
      } else {
        maxPeaks = 0;
        maxPeakCount++;
        if (maxPeakCount > 20) {
          display.clear();
        }
      }
      return render();
    };
    getPitch = function(freq) {
      var diff, key, minDiff, note, val;
      minDiff = Infinity;
      diff = Infinity;
      for (key in frequencies) {
        if (!__hasProp.call(frequencies, key)) continue;
        val = frequencies[key];
        if (Math.abs(freq - val) < minDiff) {
          minDiff = Math.abs(freq - val);
          diff = freq - val;
          note = key;
        }
      }
      return [note, diff];
    };
    display = {
      draw: function(freq) {
        var debugFreq;
        debugFreq = document.querySelector(".debug .frequency");
        return debugFreq.innerHTML = freq;
        /*
        			displayDiv = $('.tuner div')
        			displayDiv.removeClass()
        			displayDiv.addClass (if Math.abs(diff) < 0.25 then 'inTune' else 'outTune')
        			displayStr = ''
        			displayStr += if diff < -0.25 then '>&nbsp;' else '&nbsp;&nbsp;'
        			displayStr += note.replace(/[0-9]+/g, '')
        			displayStr += if diff > 0.25 then '&nbsp;<' else '&nbsp;&nbsp;'
        			displayDiv.html displayStr
        */

      },
      clear: function() {
        var debugFreq;
        debugFreq = document.querySelector(".debug .frequency");
        return debugFreq.innerHTML = "";
        /*
        			displayDiv = $('.tuner div')
        			displayDiv.removeClass()
        			displayDiv.html ''
        */

      }
    };
    render = function() {
      /*
      		context.clearRect 0, 0, canvas.width, canvas.height
      		newMaxTime = _.reduce buffer, ((max, next) -> if Math.abs(next) > max then Math.abs(next) else max), -Infinity
      		maxTime = if newMaxTime > maxTime then newMaxTime else maxTime
      		context.fillStyle = '#EEE'
      		timeWidth = (canvas.width - 100) / (buffer.length)
      		for s in [0...buffer.length]
      			context.fillRect timeWidth * s, canvas.height / 2, timeWidth, -(canvas.height / 2) * (buffer[s] / maxTime)
      		context.fillStyle = '#F77'
      		freqWidth = (canvas.width - 100) / (fft.spectrum.length / 4)
      		for f in [10...(fft.spectrum.length / 4) - 10]
      			context.fillRect freqWidth * f, canvas.height / 2, freqWidth, -Math.pow(1e4 * fft.spectrum[f], 2)
      */

    };
    return setInterval(process, 100);
  };

  error = function(e) {
    console.log(e);
    return console.log('ARE YOU USING CHROME CANARY (23/09/2012) ON A MAC WITH "Web Audio Input" ENABLED IN chrome://flags?');
  };

  navigator.getUserMedia({
    audio: true
  }, success, error);

}).call(this);
